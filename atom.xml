<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanYi&#39;s Blog</title>
  
  <subtitle>It is loneliness that makes you different,not gregariousness.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-20T06:25:04.811Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>YanYi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS开发|数据驱动UI实践-tableView多级菜单的解决思路</title>
    <link href="http://yoursite.com/2019/02/20/TableView/iOS%E5%BC%80%E5%8F%91%7C%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8UI%E5%AE%9E%E8%B7%B5-tableView%E5%A4%9A%E7%BA%A7%E8%8F%9C%E5%8D%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/02/20/TableView/iOS开发|数据驱动UI实践-tableView多级菜单的解决思路/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-02-20T06:25:04.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于“一一对应”的一些思考"><a href="#关于“一一对应”的一些思考" class="headerlink" title="关于“一一对应”的一些思考"></a>关于“一一对应”的一些思考</h2><ul><li><strong>tableView中数据与UI的关系</strong></li></ul><p>平时 ，我们的tableView需要展示多少TableViewCell，展示何种TableViewCell，都是由我们的数据来决定的，正常来说，<strong>我们的DataSource里面有多少个数据，就显示多少个cell，有多少种data就显示多少种cell，这是正常的一一对应关系，</strong>也有极少数开发者将数据与cell形成一对多的映射关系，这种做法在模块内容易造成耦合过高，通常来说不被提倡，我们只讨论一一对应的关系。</p><h3 id="数据与UI的一一对应映射模拟"><a href="#数据与UI的一一对应映射模拟" class="headerlink" title="数据与UI的一一对应映射模拟"></a><strong>数据与UI的一一对应映射模拟</strong></h3><ul><li><strong>假设我们初始的模拟数据为全部一级菜单:[[1],[1],[1],[1],[1]]</strong></li></ul><table><thead><tr><th>section</th><th>row</th><th>dataSource</th><th>tableViewCell</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>1</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>2</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>3</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>4</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr></tbody></table><ul><li><strong>当我门点击第三组的一级菜单的时候，就会打开第三组的二级菜单:[[1],[1],[1,2],[1],[1]]</strong>，即在第三组数据中加入二级菜单的数据，然后刷新UI:</li></ul><table><thead><tr><th>section</th><th>row</th><th>dataSource</th><th>tableViewCell</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>1</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>2</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td><mark>2</mark></td><td><mark>1</mark></td><td><mark>二级菜单数据</mark></td><td><mark>二级菜单cell</mark></td><td></td></tr><tr><td>3</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>4</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr></tbody></table><ul><li><strong>当我门点击第三组的二级菜单的时候，就会打开第三组的三级级菜单:[[1],[1],[1,2,3],[1],[1]]</strong>，即在第三组数据中加入三级级菜单的数据，然后刷新UI:</li></ul><table><thead><tr><th>section</th><th>row</th><th>dataSource</th><th>tableViewCell</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>1</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>2</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td><mark>2</mark></td><td><mark>1</mark></td><td><mark>二级菜单数据</mark></td><td><mark>二级菜单cell</mark></td><td></td></tr><tr><td><mark>2</mark></td><td><mark>2</mark></td><td><mark>三级菜单数据</mark></td><td><mark>三级菜单cell</mark></td><td></td></tr><tr><td>3</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr><tr><td>4</td><td>0</td><td>一级菜单数据</td><td>一级菜单cell</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      iOS开发|数据驱动UI实践-tableView多级菜单的解决思路|数据与UI一一对应关系的思考
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="TableView" scheme="http://yoursite.com/tags/TableView/"/>
    
      <category term="数据驱动UI" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8UI/"/>
    
  </entry>
  
  <entry>
    <title>通过cocoapods管理项目中的极光推送业务</title>
    <link href="http://yoursite.com/2019/01/21/%E7%BB%84%E4%BB%B6%E5%8C%96/%E9%80%9A%E8%BF%87cocoapods%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81%E4%B8%9A%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/01/21/组件化/通过cocoapods管理项目中的极光推送业务/</id>
    <published>2019-01-20T16:00:00.000Z</published>
    <updated>2019-01-21T08:47:58.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过cocoapods管理项目中的极光推送业务"><a href="#通过cocoapods管理项目中的极光推送业务" class="headerlink" title="通过cocoapods管理项目中的极光推送业务"></a>通过cocoapods管理项目中的极光推送业务</h1><h2 id="第三方业务繁多带来的问题"><a href="#第三方业务繁多带来的问题" class="headerlink" title="第三方业务繁多带来的问题"></a>第三方业务繁多带来的问题</h2><ul><li>随着公司业务的不断扩展，开发工作中要面临的业务耦合问题越来越严重，一处修改全局生效的方案也越来越不能满足代码更新的需要，为了避免过多的二次coding，就要考虑去耦合，将各个小的业务逐渐从主业务代码中剥离出来成为一个独立的单元来管理，变得越来越迫切。在iOS开发行业中，很多优秀的组件化方案层出不穷，在这个过程中，由于第三方业务的接入，可能会导致某些功能在项目中到处引用，一旦发生变动，就需要全局找代码修改，因此，第三方库的组件化管理也将变得越来越重要。</li></ul><h2 id="对于极光推送业务API管理的一些想法"><a href="#对于极光推送业务API管理的一些想法" class="headerlink" title="对于极光推送业务API管理的一些想法"></a>对于极光推送业务API管理的一些想法</h2><ul><li>前几天更新了一个老项目里面的SDK，其中就包含极光推送的SDK，由于这块业务很少会发生变动，期间一直没有留意过，更新之后就发现，很多古老的API都废弃了，崩溃，项目中相关的API使用也有蛮多的，查看了相关的代买自后，发现，变化不是特别大，那么我可以将相关的API根据自身的业务需要进行二次封装（这里就不提了，本篇文章着重组件化）。随后又想了一下，如果以后再有类似的更新怎么办呢？我总不能每次都在主工程找代码改吧？那么组件化管理的方案首先就进入了我的脑海，毕竟前段时间将其他的SDK一股脑儿的全都从主工程干掉了，但是还没有将极光推送业务放进来，那正好收拾一下这一块。</li></ul><h2 id="使用cocoapods将极光推送业务进行组件化"><a href="#使用cocoapods将极光推送业务进行组件化" class="headerlink" title="使用cocoapods将极光推送业务进行组件化"></a>使用cocoapods将极光推送业务进行组件化</h2><ul><li><p><strong>首先把业务代码给写好，那么不废话，先上代码</strong></p><ul><li>JPushApiManagerDelegate 继承<code>JPUSHRegisterDelegate</code>协议，以方便扩展协议</li></ul></li></ul><pre><code>        @protocol JPushApiManagerDelegate &lt;JPUSHRegisterDelegate&gt;        @end* JPushApiManager 单利设计，同事提供注册业务API，注册极光服务只需一个API即可        @property (nonatomic, weak ) id&lt;JPushApiManagerDelegate&gt; delegate;        + (instancetype)sharedManager;        /**            注册极光服务            @param appKey appKey            @param launchOptions launchOptions            @param delegate delegate        */        - (void)setJPushAppKey:(nonnull NSString *)appKey             didFinishLaunchingWithOptions:(nonnull NSDictionary *)launchOptions delegate:(nonnull id&lt;JPushApiManagerDelegate&gt;)delegate;        @end* APPDelegate      **一行代码即可搞定，didfinishlaunching方法中的代码尽可能保持干净**        #import &quot;AppDelegate.h&quot;        #import &quot;JPushApiManager.h&quot;        static NSString * const JPushAppKey = @&quot;在这里填写你的极光推送AppKey&quot;;        @interface AppDelegate ()&lt;JPushApiManagerDelegate&gt;        @end        - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {            [[JPushApiManager sharedManager] setJPushAppKey:JPushAppKey didFinishLaunchingWithOptions:launchOptions delegate:self];            return YES;        }* JPUSHRegisterDelegate **写到`APPdelegate`里**        // iOS 10 Support        - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center             willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(NSInteger))completionHandler {            // Required            NSDictionary * userInfo = notification.request.content.userInfo;            if([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {            [JPUSHService handleRemoteNotification:userInfo];            }            completionHandler(UNNotificationPresentationOptionAlert); // 需要执行这个方法，选择是否提醒用户，有Badge、Sound、Alert三种类型可以选择设置        }        // iOS 10 Support        - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler {            // Required            NSDictionary * userInfo = response.notification.request.content.userInfo;            if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) {                [JPUSHService handleRemoteNotification:userInfo];            }            completionHandler();        }        // iOS 12        - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(nullable UNNotification *)notification {        }        - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {            // Required, iOS 7 Support            [JPUSHService handleRemoteNotification:userInfo];            completionHandler(UIBackgroundFetchResultNewData);        }</code></pre><ul><li><p>至此，相关的编码工作就完成了，接下来就是使用cocoapods将代码进行组件化管理</p><ul><li><p>在工程根目录下运行如下代码</p><pre><code>$ pod spec create JPushApiManager$ vim JPushApiManager.podspec</code></pre></li><li><p>修改.podspec文件内容如下</p></li></ul></li></ul><pre><code>        Pod::Spec.new do |s|            s.name         = &quot;JPushApiManager&quot;            s.version      = &quot;3.1.2.1&quot;            s.summary      = &quot;组件化方式管理极光推送代码&quot;            s.description  = &lt;&lt;-DESC                组件化方式管理极光推送代码，以方便代码中一处修改全局生效               DESC            s.homepage     = &quot;https://github.com/XFNicar/JPushApiManager&quot;            s.license      = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; }            s.author             = { &quot;XieFei&quot; =&gt; &quot;xuejingwen25@163.com&quot; }            s.platform     = :ios, &quot;9.0&quot;            s.source       = { :git =&gt; &quot;https://github.com/XFNicar/JPushApiManager.git&quot;, :tag =&gt; &quot;#{s.version}&quot; }            s.source_files  = &quot;JPushApiManager/JPushApiManager/*.{h,m}&quot;            s.requires_arc = true            # s.ios.vendored_libraries = &apos;libs/*.a&apos;            s.dependency &quot;JPush&quot;, &quot;~&gt; 3.1.2&quot;        end* 提交代码        $ git add .        $ git commit -m &quot;nothing&quot;        $ git push origin master        $ git tag -a 3.1.2.1 -m &quot;发布3.1.2.1版本&quot;        $ git push origin --tags* 校验.podspec文件的正确性        $ pod lib lint --use-libraries --allow-warnings* 发布代码        $ pod trunk push JPushApiManager.podspec* 看到如下效果就说明发布成功了        --------------------------------------------------------------------------------        🎉  Congrats        🚀  JPushApiManager (3.1.2.1) successfully published        📅  January 20th, 23:10        🌎  https://cocoapods.org/pods/JPushApiManager        👍  Tell your friends!        --------------------------------------------------------------------------------* 在工程中导入代码        pod &apos;JPushApiManager&apos;, &apos;~&gt; 3.1.2.1&apos;</code></pre><h2 id="说在后面"><a href="#说在后面" class="headerlink" title="说在后面"></a>说在后面</h2><ul><li><p>至此极光推送业务组件化管理的相关工作就结束了，组件化带来的好处是很明显的，此次组件化的目的有三点：</p><pre><code>1. 如果项目中有部分需要主动触发推送业务的代码，那么就可以统一定制API，防止官方API发生改变之后，需要重新搜索代码来修改。2. 将业务进行剥离，可以单独在一个模块里管理极光推送业务。3. 让项目中代码更加干净整洁。4. 装逼。。。2333333</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      通过cocoapods进行组件化管理极光推送业务，提高代码管理质量，避免一处废弃，全局review的尴尬现象。
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="cocoapods" scheme="http://yoursite.com/tags/cocoapods/"/>
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="极光推送" scheme="http://yoursite.com/tags/%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>解决pod lib lint xxx.podspec不支持i386编译环境</title>
    <link href="http://yoursite.com/2019/01/21/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%B0%E7%9A%84%E5%9D%91/pod%20lib%20lint%20pod%E4%B8%8D%E6%94%AF%E6%8C%81i386%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/01/21/组件化到的坑/pod lib lint pod不支持i386编译环境/</id>
    <published>2019-01-20T16:00:00.000Z</published>
    <updated>2019-01-21T08:38:39.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题发生"><a href="#问题发生" class="headerlink" title="问题发生"></a>问题发生</h2><ul><li><p>最近在准备将极光推送的SDK进行组件化管理的过程中，碰到了怎么都校验不通过的问题，一开始一直以为是我添加静态库的方式有问题吧，但事实上并没有，经过了多次修改之后，感到一丝灰心，报错信息如下：</p><pre><code>The following build commands failed:Ld /Users/YanYi/Library/Developer/Xcode/DerivedData/App-dokqufshqekrqxajlpsxnsqnccom/Build/Intermediates.noindex/App.build/Release-iphonesimulator/App.build/Objects-normal/i386/App normal i386(1 failure)Testing with `xcodebuild`.-&gt; JPushApiManager (3.1.2)- ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code.</code></pre><p>其中有两条提示如下：</p></li></ul><pre><code>- NOTE  | [iOS] xcodebuild:  ld: warning: ignoring file /Users/YanYi/Desktop/PublicPodsCode/JPushApiManager/libs/libjcore-ios-1.2.6.a, missing required architecture i386 in file /Users/YanYi/Desktop/PublicPodsCode/JPushApiManager/libs/libjcore-ios-1.2.6.a (4 slices)- NOTE  | [iOS] xcodebuild:  ld: warning: ignoring file /Users/YanYi/Desktop/PublicPodsCode/JPushApiManager/libs/libjpush-ios-3.1.2.a, missing required architecture i386 in file /Users/YanYi/Desktop/PublicPodsCode/JPushApiManager/libs/libjpush-ios-3.1.2.a (4 slices)</code></pre><p>  顺着 <code>missing required architecture i386 in file</code> 的提示，可以大致知道该库<strong>在i386环境下校验不通过</strong>，到网上一找，崩溃。。。原来，<strong>你只要确定第三方库没问题，还有可以跳过相应平台校验</strong>这一说的：</p><p>  <strong>那么照着来吧!</strong></p><ul><li><p>终端输入如下命令找到cocoapods的安装位置</p><pre><code>$ gem which cocoapods</code></pre><ul><li><p>得到提示:</p><pre><code>$ /usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-1.5.3/lib/cocoapods.rb</code></pre></li></ul></li></ul><ul><li><p>进入到 <code>/usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-1.5.3/lib/</code>目录下找到并打开 <code>validator.rb</code> 文件，找到如下代码:</p><pre><code># @return [String] Executes xcodebuild in the current working directory and#         returns its output (both STDOUT and STDERR).#def xcodebuild(action, scheme, configuration)    require &apos;fourflusher&apos;    command = %W(clean #{action} -workspace #{File.join(validation_dir, &apos;App.xcworkspace&apos;)} -scheme #{scheme} -configuration #{configuration})    case consumer.platform_name    when :osx, :macos        command += %w(CODE_SIGN_IDENTITY=)    when :ios        command += %w(CODE_SIGN_IDENTITY=- -sdk iphonesimulator)        command += Fourflusher::SimControl.new.destination(:oldest, &apos;iOS&apos;, deployment_target)        #        command += %w(--help)    when :watchos        command += %w(CODE_SIGN_IDENTITY=- -sdk watchsimulator)        command += Fourflusher::SimControl.new.destination(:oldest, &apos;watchOS&apos;, deployment_target)    when :tvos        command += %w(CODE_SIGN_IDENTITY=- -sdk appletvsimulator)        command += Fourflusher::SimControl.new.destination(:oldest, &apos;tvOS&apos;, deployment_target)    end    begin        _xcodebuild(command, true)        rescue =&gt; e        message = &apos;Returned an unsuccessful exit code.&apos;        message += &apos; You can use `--verbose` for more information.&apos; unless config.verbose?        error(&apos;xcodebuild&apos;, message)        e.message    endend</code></pre></li></ul><p>将如下两行代码注掉</p><pre><code>when :ios    command += %w(CODE_SIGN_IDENTITY=- -sdk iphonesimulator)    command += Fourflusher::SimControl.new.destination(:oldest, &apos;iOS&apos;, deployment_target)</code></pre><p>改成如下代码即可:</p><pre><code>command += %w(--help)</code></pre><p><strong>该做法直接跳过了iOS平台的校验</strong>，不会再出现报错，但相应的，你的代码<strong>如果真的有错误也不会提示</strong>，所以需要<strong>确保自己的代码没问题</strong>再来修改这个地方。</p>]]></content>
    
    <summary type="html">
    
      创建自己的pod库的时候，有时候也会应用第三方静态库，但是有些第三方静态库不支持i386编译环境，该如何避免校验不通过的问题呢？
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="cocoapods" scheme="http://yoursite.com/tags/cocoapods/"/>
    
      <category term="坑" scheme="http://yoursite.com/tags/%E5%9D%91/"/>
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="静态库" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
      <category term="i386" scheme="http://yoursite.com/tags/i386/"/>
    
  </entry>
  
  <entry>
    <title>导入、更新TencentOpenApi 运行报错</title>
    <link href="http://yoursite.com/2019/01/11/TencentOpenApi%E5%A1%AB%E5%9D%91/"/>
    <id>http://yoursite.com/2019/01/11/TencentOpenApi填坑/</id>
    <published>2019-01-10T16:00:00.000Z</published>
    <updated>2019-01-11T08:35:29.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul><li>一些发现和建议：我这里使用SDK实现QQ平台的相关分享功能。网上其实也有蛮多相关的文章提到了这个错误，但是都没有明确说明是什么问题，或者只是告诉你怎么处理之后就好了，但是并没细致分析是什么原因。其实这是个很简单的问题，恨只能恨很多同学看到英文报错就内心发慌，其实没几个单词，看仔细点就知道是什么原因了。</li></ul><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p><strong>接下来我们就分析：</strong></p><ul><li><p><strong>导入TencentOpenApi SDK，或者更新TencentOpenApi之后运行报如下错误</strong></p><p>  Undefined symbols for architecture arm64:</p><pre><code>&quot;l_OBJC_PROTOCOL_$_TencentApiInterfaceDelegate&quot;, referenced from:l_OBJC_CLASS_PROTOCOLS_$_AppDelegate in AppDelegate.o</code></pre></li></ul><ol><li><p>很显然，根据 <code>l_OBJC_PROTOCOL_$_TencentApiInterfaceDelegate</code> 和 <code>l_OBJC_CLASS_PROTOCOLS_</code> 两个关键信息可以定位到，问题出在<code>TencentApiInterfaceDelegate</code>这个协议上面。</p></li><li><p>我们进一步提取信息：根据<code>l_OBJC_CLASS_PROTOCOLS_$_AppDelegate in AppDelegate.o</code>可以明显的定位到问题就在APPDelegate里面。</p></li></ol><p>那么我们就到Appdelegate文件中去一探究竟</p><ol><li><p>来到APPdelegate.m 文件里，相关代码如下:</p><pre><code>@interface AppDelegate ()&lt;JPUSHRegisterDelegate,TencentApiInterfaceDelegate&gt; {TencentOAuth    *_TencentOAuth;}</code></pre><ul><li><strong>发现APPdelegate引用的协议中有一个警告<code>Cannot find protocol definition for &#39;TencentApiInterfaceDelegate&#39;</code>，提示我们没有找到该协议的定义：</strong></li></ul></li></ol><!-- <img src="2019/01/11/TencentOpenApi填坑/2019/01/11/TencentOpenApi填坑/协议警告1.0.jpg" alt="引用协议警告"> --><!-- ![引用协议警告](TencentOpenApi填坑/协议警告1.0.jpg) --><ul><li><p><strong>由于我是在很久之前就使用了这个SDK，最近为了将项目组件化，顺便把SDK也做了更新,并做了组件化封装，所以这里是老代码，以前这里没有改过</strong>，那么我们点到这个协议的相关代码去看看究竟：</p><pre><code>#import &lt;UIKit/UIKit.h&gt;#import &quot;sdkdef.h&quot;@protocol TencentSessionDelegate;@protocol TencentLoginDelegate;@protocol TencentApiInterfaceDelegate;@protocol TencentWebViewDelegate;@class TencentApiReq;@class TencentApiResp;</code></pre></li></ul><ul><li><strong>然后我们可以看到，果不其然，这四个协议除了在这里进行了名称定义之外，完全没有具体的定义，我在全局搜索一下也没有搜到，那么问题就简单了，没有实现，说明没用呗，我们还要啥自行车。你遗弃了老东西自然要把新的API拿出来，既然我是要QQ分享，那么就从QQApiInterface中去找，果不其然，在QQApiInterface.h中找到如下信息：</strong></li></ul><pre><code>/**\brief 处理来至QQ的请求及响应的回调协议*/@protocol QQApiInterfaceDelegate &lt;NSObject&gt;/** 处理来至QQ的请求*/- (void)onReq:(QQBaseReq *)req;/**处理来至QQ的响应 */- (void)onResp:(QQBaseResp *)resp;/**处理QQ在线状态的回调*/ - (void)isOnlineResponse:(NSDictionary *)response;@end</code></pre><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ul><li>那么我们引入<code>QQApiInterface.h</code>头文件，把<code>TencentApiInterfaceDelegate</code>替换成<code>QQApiInterfaceDelegate</code>再次运行，完美。</li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul><li>debug就算到此结束，但还有一点要吐槽的是，<strong>现在的工程都是比较大的，警告一般来说都非常多，像这种警告，很多人都不会在意</strong>，那么我想说的是，在腾讯的<strong>SDK中保留这种没有具体定义的协议</strong>，很容易给相关开发者带来这样的一些困扰，<strong>尤其是这种看起来是一个父协议，而在SDK中没有找到任何定义，也没有任何子协议继承</strong>，这就让人非常不解为什么要把代码写成这个样子。好吧，吐槽结束。希望大家能够给大家一点帮助。</li></ul>]]></content>
    
    <summary type="html">
    
      导入或更新TencentOpenApi运行报错Undefined symbols for architecture arm64:&quot;l_OBJC_PROTOCOL_$_TencentApiInterfaceDelegate&quot;, referenced from:l_OBJC_CLASS_PROTOCOLS_$_AppDelegate in AppDelegate.o
    
    </summary>
    
      <category term="填坑笔记" scheme="http://yoursite.com/categories/%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="填坑笔记" scheme="http://yoursite.com/tags/%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="TencentOpenApi" scheme="http://yoursite.com/tags/TencentOpenApi/"/>
    
      <category term="l_OBJC_CLASS_PROTOCOLS_" scheme="http://yoursite.com/tags/l-OBJC-CLASS-PROTOCOLS/"/>
    
  </entry>
  
  <entry>
    <title>用 cocoapods 创建私有库</title>
    <link href="http://yoursite.com/2018/12/02/cocoapods/%E7%94%A8%20cocoapods%20%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/02/cocoapods/用 cocoapods 创建私有库/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2018-12-02T17:31:08.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><a name="markdown-pane-写在前面"></a>写在前面</h2><blockquote><p><strong>文章主要部分</strong></p><blockquote><p><a href="#markdown-pane-写在前面"><strong>写在前面</strong></a></p><p><a href="#markdown-pane-关于cocoapods的一些小知识"><strong>关于cocoapods的一些小知识</strong></a></p><p><a href="#markdown-pane-两个重要的仓库"><strong>两个重要的仓库</strong></a></p><p><a href="#markdown-pane-上手集成"><strong>上手集成</strong></a></p></blockquote><p>如果不需要细究<strong><code>cocoapods</code></strong>的一些工作细节，那么我们可以直接开始<a href="#markdown-pane-上手集成"><strong>上手集成</strong></a></p></blockquote><p>##<a name="markdown-pane-关于cocoapods的一些小知识"></a>关于cocoapods的一些小知识 </p><blockquote><p><strong>来到这里的小伙伴，通常都已经有了使用<code>cocoapods</code>的经验，那么废话不多说，我们直接在终端打开目录</strong></p></blockquote><pre><code>$ open ~/.cocoapods/repos</code></pre><blockquote><p><strong>接下来我们可以看到如下目录结构</strong></p></blockquote><pre><code>.                                            ├── Specs                                # 索引库列表    └── [REPO_NAME]                     # 索引库名（其中master为cocoapods官方索引库）        └── [SPEC_NAME]                    # 第三方库名            └── [VERSION]                # 第三方库版本                  └── [SPEC_NAME].podspec    # 第三方库的版本说明文件</code></pre><blockquote><p>根据以上目录我们不难看出，索引库中存着不同名称的索引库，即<strong><code>spec repo</code></strong>（没有私有库的话，只有一个<strong><code>master</code></strong>），在索引库<strong><code>spec repo</code></strong>目录下才包含各种以第三方库名命名的文件夹<strong><code>如：AFNetworking</code></strong>，在这些文件夹下包含以不同版本号命名的文件夹<strong><code>如3.0.0等</code></strong>，再点开就会看到一个诸如<strong><code>AFNetworking.podspec</code></strong>的文件，那么这个就是有关于<strong><code>AFNetworking</code></strong>这个库在<strong><code>3.0.0</code></strong>版本下的描述文件，关于这个目录我们就先了解到这里，并没有任何难点，是不是挺无聊，那么由浅入深，我们接着往下走。</p></blockquote><p><strong>关于cocoapods的一些基本工作原理</strong></p><ul><li><p>我们把cocoapods 想象成一个工具，当我们运行 <code>pod install</code> 的时候，他帮我们做了两件事情，事实上，<strong><code>cocoapods</code></strong>为我们所有我们看得见看不见的工作，其根本目的就是以下两点：</p><pre><code>1. 帮我们找到我们需要的库2. 把我们需要的库集成到我们的工程里面</code></pre></li><li><p><strong>对于第一件事情，相信绝大多数的人单从字面意思都可以很容易理解</strong>，甚至很多人都会进一步思考<strong><code>cocoapods</code></strong>究竟是怎么帮我们搜的，那么我们一会就来探究一下<strong><code>cocoapods</code></strong>是怎么为开发者做到这第一件事情的吧。</p></li><li><p>关于cocoapods为我们做的第二件事情，里面包含着许多的细节性工作，鉴于个人能力目前也不在这个范围内，这里也就无法细述，但并不影响我们接下来的所有工作。</p></li></ul><p>##<a name="markdown-pane-两个重要的仓库"></a>两个重要的仓库 </p><h3 id="spec-repository-描述文件仓库-即索引库"><a href="#spec-repository-描述文件仓库-即索引库" class="headerlink" title="spec repository 描述文件仓库(即索引库)"></a>spec repository 描述文件仓库(即索引库)</h3><p>通常我们指的是<strong><code>cocoapods</code></strong>项目在GitHub上<strong>存放各种第三方库的版本描述文件<code>.podspec</code>的仓库</strong>（称之为<strong>索引库</strong>），也就是<strong><a href="https://github.com/CocoaPods/Specs" target="_blank" rel="noopener">官方Spec Repo</a></strong> ，当你使用<strong><code>cocoapods</code></strong>时，它就会被clone到你的本地。这个仓库在<strong><code>cocoapods</code></strong>的设计中起到了关键的一环。</p><p>当你用<strong><code>cocoapods</code></strong>项工程中导入某个库的的时候，首先要做的事情就是寻找你在<strong><code>.Podfile</code></strong>文件里添加的相关库的在哪里，那么我们是不是应该要想，去哪里找呢？答案呢当然是clone到本地的<strong><code>cocoapods</code></strong>索引库<strong><code>spec repo</code></strong>了。</p><p>现在我们就简单来扒一下我们每次在终端执行<code>pod install</code> 究竟做了些什么：</p><ul><li><p><strong><code>$ pod install</code></strong> </p></li><li><p><strong>到<code>Podfile</code>中提取<code>pod &#39;AFNetworking&#39;, &#39;~&gt; 1.1.1&#39;</code></strong></p></li><li><p><strong>到clone到本地的索引库<code>spec repo</code>中搜索名为<code>AFNetworking</code>的文件夹</strong></p></li><li><p><strong>在找到的<code>AFNetworking</code>目录下寻找名为<code>1.1.1</code>的文件夹</strong></p></li><li><p><strong>根据<code>1.1.1</code>文件夹中的<code>AFNetworking.podspec</code> 版本描述文件中的具体信息去相应的代码仓库下载or拷贝<code>AFNetworking 1.1.1</code>版本的相关代码</strong></p></li><li><p><strong>将<code>AFNetworking 1.1.1</code>版本的代码集成到我们工程中</strong></p></li></ul><h3 id="code-repository-（第三方库的代码仓库）"><a href="#code-repository-（第三方库的代码仓库）" class="headerlink" title="code repository （第三方库的代码仓库）"></a>code repository （第三方库的代码仓库）</h3><ul><li><strong><code>code repo</code></strong> 是各种第三方库的实际代码存放仓库，一般托管在<code>GitHub</code>、<code>gitlab</code>等代码托管网站或私有服务器上。该仓库中附带也会包含一个当前库的版本描述文件<strong><code>.podspec</code></strong>文件，<strong><code>.podspec</code></strong>文件中包含该库当前版本的详细描述，后面会做详细解释说明。</li></ul><p>##<a name="markdown-pane-上手集成"></a>上手集成</p><ol><li><p><strong>安装<code>cocopods</code></strong> </p><blockquote><p>如果没有安装的同学，网上有很多教程，随便搜就可以找到很多。</p></blockquote></li><li><p><strong>在<code>GitHub、gitlab</code>等网站/服务器上创建私有的代码仓库 <code>code repo</code>，比如我们创建一个<code>VeryNBKit</code>仓库</strong></p><blockquote><p>在代码托管网站上创建私有的代码仓库，用来保存你的私有库中的代码。</p></blockquote></li><li><p><strong>在<code>GitHub、gitlab</code>等网站/服务器上创建私有索引库 <code>spec repo</code></strong></p><blockquote><p>在前面的<a href="#markdown-pane-关于cocoapods的一些小知识">小知识</a>中，我们提到在 <code>~/.cocoapods/repos</code> 目录下包含有不同名称的索引库，其中<strong><code>master</code></strong>为<code>cocoapods</code>官方的索引库，也就是绝大多数公有库的索引库，如果我们写的<strong>私有库代码</strong>都非常牛逼，又不想开源，又想使用<strong><code>cocoapods</code></strong>来管理我们的<strong>私有代码库</strong>，那么我们干脆就把我们的<strong>私有索引库</strong>命名为<strong><code>VeryNBSpecs</code></strong>。</p><p>到此为止，我们的两个重要的仓库就创建完毕了，接下来的工作将需要更加细心了。</p></blockquote></li><li><p><strong>将仓库clone到本地</strong></p><pre><code>$ git clone https://github.com/YourName/VeryNBKit.git</code></pre></li><li><p><strong>在仓库根目录创建Xcode工程</strong></p><blockquote><p>创建VeryNBKit 项目工程</p></blockquote></li><li><p><strong>在Xcode中编写相关代码</strong></p><blockquote><p>编写VeryNBKit 中那些牛逼的代码</p></blockquote></li><li><p><strong>创建 VeryNBKit.podspec 文件  (VeryNBKit为牛逼的库名)</strong></p><blockquote><p>我们知道，当我们光写完这些牛逼的代码，上传到代码托管服务器上之后，<strong><code>cocoapods</code></strong>并不知道我们这些牛逼的代码在哪里，如果我们在Podflie中写到<code>pod &#39;VeryNBKit&#39;, &#39;~&gt; 1.1.1&#39;</code>，然后在终端执行<code>pod install</code>，其实<code>cocoapods</code>并不能认识（找到）我们的牛逼代码，这么牛逼的代码你不认识，那逼没法装下去了呀，这可是不行的！！！</p><p>我们知道，<code>cocoapods</code>必须要通过<code>.podspec</code>文件来定位我们牛逼的代码在哪里，然后才能把代码拷贝过来集成到我们的工程里，那么废话不说，直接将<code>.podspec</code>文件甩到<code>cocoapods</code>脸上看他认识不认识。</p></blockquote><p> <strong>打开终端，直接来到<code>VeryNBKit</code>工程的根目录下，执行如下指令，将会为我们创建<code>VeryNBKit.podspec</code>文件。</strong></p><pre><code>$ pod spec create VeryNBKit </code></pre><p> <strong>现在<code>.podspec</code>文件有了，接下来在这个文件中加点信息，告诉<code>cocoapods</code>在哪里找我们的<code>VeryNBKit</code>。</strong></p></li><li><p><strong>编辑 VeryNBKit.podspec 文件</strong></p><pre><code>Pod::Spec.new do |s|      s.name         = &quot;VeryNBKit&quot; # 项目名称      s.version      = &quot;0.0.1&quot;        # 版本号 与 你仓库的 标签号 对应      s.license      = &quot;MIT&quot;          # 开源证书      s.summary      = &quot;A delightful TextField of VeryNBKit&quot; # 项目简介      s.homepage     = &quot;https://github.com/YourName/VeryNBKit&quot; # 你的主页      s.source       = { :git =&gt; &quot;https://github.com/YourName/VeryNBKit.git&quot;, :tag =&gt;             &quot;#{s.version}&quot; }#你的仓库地址，不能用SSH地址      s.source_files  = &quot;VeryNBKit/VeryNBKit/*.{h,m}&quot;&quot;      # 你代码的位置，以上路径以.podspec文件所在位置为根目录，一直到实际代码所在位置为止，说明如下      # VeryNBKit/VeryNBKit/*.{h,m}       # VeryNBKit/VeryNBKit/**/*.{h,m}     # 表示 VeryNBKit/VeryNBKit/ 和 VeryNBKit/VeryNBKit/ 文件夹下所有.h和.m文件，以及其子目录下的.h和.m文件      s.requires_arc = true # 是否启用ARC      s.platform     = :ios, &quot;7.0&quot; #平台及支持的最低版本      s.frameworks   = &quot;UIKit&quot;, &quot;Foundation&quot; #支持的框架      # s.dependency   = &quot;AFNetworking&quot; # 依赖库 （如有）      # User      s.author             = { &quot;YourName&quot; =&gt; &quot;YourName@gmail.com&quot; } # 作者信息      s.social_media_url   = &quot;https://YourName.github.io&quot; # 个人主页end</code></pre></li><li><p><strong>按照如上内容填好之后，我们需要验证podspec文件</strong>    </p><pre><code>$ pod lib lint</code></pre><blockquote><p>当我们看到如下提示，则说明验证通过了</p></blockquote><pre><code>-&gt; VeryNBKit (0.0.1)- NOTE  | xcodebuild:  note: Using new build system- NOTE  | [iOS] xcodebuild:  note: Planning build- NOTE  | [iOS] xcodebuild:  note: Constructing build description- NOTE  | [iOS] xcodebuild:  warning: Skipping code signing because the target does not have an Info.plist file. (in target &apos;App&apos;)VeryNBKit passed validation.</code></pre></li><li><p><strong><code>VeryNBKit.podspec</code>验证通过之后，我们就需要把代码上传到代码库了</strong></p><pre><code>$ git add .$ git commit -m &quot;提交信息&quot;$ git push origin master给仓库打标签标签相当于将你的仓库的一个压缩包，用于稳定存储当前版本。标签号与你在 s.version = &quot;1.0.0&quot;的版本号一致 1.0.0$ git tag -a XXX -m &quot;发布XXX版本&quot; $ git push origin --tags</code></pre></li><li><p><strong>发布 <code>VeryNBKit.podspec</code></strong></p><p>将<code>VeryNBKit.podspec</code>发布之前，我们是否还记得我们的私有索引库<code>VeryNBSpecs</code>，没错，如果我们发布到私有库，那么就需要先把我们的<code>VeryNBSpecs</code>添加到我们的<code>spec repo</code>列表中去，在终端中执行如下命令：</p><pre><code>$ pod repo add VeryNBSpecs https://gitlab.com/YourName/VeryNBSpecs.git</code></pre><p>完了之后，我们可以打开<code>~/.cocoapods/repos</code></p><pre><code>$ open ~/.cocoapods/repos</code></pre><p>是不是会惊喜的发现，多了一个<code>VeryNBSpecs</code>文件夹，没错，就是我们的牛逼代码索引库。</p><p>最后我们将<code>VeryNBKit.podspec</code> push到<code>VeryNBSpecs</code>索引库</p><pre><code>$ pod repo push VeryNBSpecs VeryNBKit.podspec </code></pre></li><li><p><strong>pod搜索一下我们的<code>VeryNBKit</code></strong></p><pre><code>$ pod search VeryNBKit</code></pre><p>搜到了吧，恭喜你，成功了！！！</p></li></ol>]]></content>
    
    <summary type="html">
    
      用 cocoapods 创建私有库
    
    </summary>
    
      <category term="cocoapods" scheme="http://yoursite.com/categories/cocoapods/"/>
    
    
      <category term="cocoapods" scheme="http://yoursite.com/tags/cocoapods/"/>
    
      <category term="cocoapods 私有库" scheme="http://yoursite.com/tags/cocoapods-%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>用 cocoapods 创建公有库（以GitHub为例）</title>
    <link href="http://yoursite.com/2018/11/25/cocoapods/%E7%94%A8%20cocoapods%20%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E5%BA%93/"/>
    <id>http://yoursite.com/2018/11/25/cocoapods/用 cocoapods 创建公有库/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2018-12-02T17:30:09.016Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>安装cocopods (网上查找教程)</p></li><li><p>在GitHub上创建仓库，</p></li><li><p>将仓库clone到本地</p><pre><code>$ git clone https://github.com/YourName/REPO_NAME.git</code></pre></li><li><p>在仓库根目录创建Xcode工程</p></li><li><p>在Xcode中编写相关代码</p></li><li><p>在项目根目录创建 XXX.podspec 文件  (XXX为库名)</p><pre><code>$ pod spec create XXX (XXX:库名)</code></pre></li><li><p>编辑podspec文件</p><pre><code>Pod::Spec.new do |s|      s.name         = &quot;SpeedyKit&quot; # 项目名称      s.version      = &quot;0.0.1&quot;        # 版本号 与 你仓库的 标签号 对应      s.license      = &quot;MIT&quot;          # 开源证书      s.summary      = &quot;A delightful TextField of SpeedyKit&quot; # 项目简介      s.homepage     = &quot;https://github.com/XFNicar/SpeedyKit&quot; # 你的主页      s.source       = { :git =&gt; &quot;https://github.com/XFNicar/SpeedyKit.git&quot;, :tag =&gt;             &quot;#{s.version}&quot; }#你的仓库地址，不能用SSH地址      s.source_files  = &quot;SpeedyKit/SpeedyKit/UIKit/**/*.{h,m}&quot;, &quot;SpeedyKit/SpeedyKit/Foundation/**/*.{h,m}&quot;      # 你代码的位置，以上路径以.podspec文件所在位置为根目录，一直到实际代码所在位置为止，说明如下      # SpeedyKit/SpeedyKit/UIKit/**/*.{h,m}       # SpeedyKit/SpeedyKit/Foundation/**/*.{h,m}     # 表示 SpeedyKit/SpeedyKit/UIKit/ 和 SpeedyKit/SpeedyKit/Foundation/ 文件夹下所有文件夹及其目录下的.h和.m文件      s.requires_arc = true # 是否启用ARC      s.platform     = :ios, &quot;7.0&quot; #平台及支持的最低版本      s.frameworks   = &quot;UIKit&quot;, &quot;Foundation&quot; #支持的框架      # s.dependency   = &quot;AFNetworking&quot; # 依赖库 （如有）      # User      s.author             = { &quot;XFNicar&quot; =&gt; &quot;xuejingwen25@163.com&quot; } # 作者信息      s.social_media_url   = &quot;https://XFNicar.github.io&quot; # 个人主页end</code></pre></li><li><p>验证podspec文件    </p><pre><code>$ pod lib lint    验证通过即可开始提交代码到GitHub        </code></pre></li><li><p>提交代码到GitHub</p><pre><code> $ git add .$ git commit -m &quot;提交信息&quot;$ git push origin master</code></pre></li><li><p>给仓库打标签</p><pre><code>标签相当于将你的仓库的一个压缩包，用于稳定存储当前版本。标签号与你在 s.version = &quot;1.0.0&quot;的版本号一致 1.0.0$ git tag -a XXX -m &quot;发布XXX版本&quot; $ git push origin --tags</code></pre></li><li><p>发布 <strong>.podspec</strong></p><pre><code>$ pod trunk push SpeedyKit.podspec </code></pre><p>看到如下提示则表示发布成功了</p><pre><code>-------------------------------------------------------------------------------- 🎉  Congrats 🚀  SpeedyKit (0.0.1) successfully published 📅  November 27th, 10:13 🌎  https://cocoapods.org/pods/SpeedyKit 👍  Tell your friends!--------------------------------------------------------------------------------</code></pre></li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li><p>校验 .podspec 的时候报如下错误</p><pre><code>$ pod search speedykit[!] ConvenientKit did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it).You can use the `--no-clean` option to inspect any issue.</code></pre><p> 该情况一般是因为没有创建LICENSE 文件所引起的，添加LICENSE 文件即可，也可以使用<code>--allow-warnings</code>命令消除报错</p></li><li><p>发布.podspec 的时候提示如下信息</p><pre><code>$ pod trunk push SpeedyKit.podspec[!] You (xxxx@gmail.com) are not allowed to push new versions for this pod. The owners of this pod are xxxx@gmail.com.</code></pre><p> 抱歉你的库名已经被占用，请换其他的吧</p></li><li><p>搜索不到库</p><pre><code>$ pod search speedykit[!] Unable to find a pod with name, author, summary, or description matching `speedykit`</code></pre><p> 解决办法 ：删掉本地的搜索目录文件即可</p><pre><code>$ rm ~/Library/Caches/CocoaPods/search_index.json</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      用 cocoapods 创建公有库（以GitHub为例。
    
    </summary>
    
      <category term="cocoapods" scheme="http://yoursite.com/categories/cocoapods/"/>
    
    
      <category term="cocoapods" scheme="http://yoursite.com/tags/cocoapods/"/>
    
      <category term="cocoapods 公有库" scheme="http://yoursite.com/tags/cocoapods-%E5%85%AC%E6%9C%89%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Flutter环境配置报错:Requested &#39;libusbmuxd &gt;= 1.1.0&#39; but version of libusbmuxd is 1.0.10</title>
    <link href="http://yoursite.com/2018/10/22/Flutter%E7%AC%94%E8%AE%B0/Flutter%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/22/Flutter笔记/Flutter环境配置问题/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-23T02:58:53.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="执行-brew-install-–HEAD-libimobiledevice-报错"><a href="#执行-brew-install-–HEAD-libimobiledevice-报错" class="headerlink" title="执行 brew install –HEAD libimobiledevice 报错"></a>执行 brew install –HEAD libimobiledevice 报错</h2><pre><code>brew install --HEAD libimobiledevice==&gt; ./autogen.shLast 15 lines from /Users/YanYi/Library/Logs/Homebrew/libimobiledevice/01.autogen.sh:checking dynamic linker characteristics... darwin18.0.0 dyldchecking how to hardcode library paths into programs... immediatechecking for pkg-config... /usr/local/opt/pkg-config/bin/pkg-configchecking pkg-config is at least version 0.9.0... yeschecking for libusbmuxd &gt;= 1.1.0... noconfigure: error: Package requirements (libusbmuxd &gt;= 1.1.0) were not met:Requested &apos;libusbmuxd &gt;= 1.1.0&apos; but version of libusbmuxd is 1.0.10Consider adjusting the PKG_CONFIG_PATH environment variable if youinstalled software in a non-standard prefix.Alternatively, you may set the environment variables libusbmuxd_CFLAGSand libusbmuxd_LIBS to avoid the need to call pkg-config.See the pkg-config man page for more details.READ THIS: https://docs.brew.sh/Troubleshooting </code></pre><ul><li>原因 </li></ul><p><strong>很明显libimobiledevice已经更新了，那么我们肯定要安装新版本。</strong></p><ul><li>解决方案 </li></ul><p><strong>既然直接安装不行，那就卸载重装</strong></p><p>  brew update<br>  brew uninstall –ignore-dependencies libimobiledevice<br>  brew uninstall –ignore-dependencies usbmuxd<br>  brew install –HEAD usbmuxd<br>  brew unlink usbmuxd<br>  brew link usbmuxd<br>  brew install –HEAD libimobiledevice</p>]]></content>
    
    <summary type="html">
    
      解决Flutter环境配置报错：Requested &#39;libusbmuxd &gt;= 1.1.0&#39; but version of libusbmuxd is 1.0.10
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>未能完成该操作。协议错误 （NSPOSIXErrorDomain Code=100）</title>
    <link href="http://yoursite.com/2018/10/22/OC%E4%B8%8EJS%20%E4%BA%A4%E4%BA%92/HTTPS%E7%BD%91%E9%A1%B5%E5%9C%A8iPhone%E5%92%8CSafari%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E4%B8%8D%E5%BC%80%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%89%E5%8D%93%E5%92%8C%E5%85%B6%E4%BB%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AF%E4%BB%A5%E6%89%93%E5%BC%80/"/>
    <id>http://yoursite.com/2018/10/22/OC与JS 交互/HTTPS网页在iPhone和Safari浏览器打不开，但是安卓和其他浏览器可以打开/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-22T06:09:09.257Z</updated>
    
    <content type="html"><![CDATA[<p>今天早上，iOS平台APP突然不能打开HTML5页面，而在半小时之前是可以打开的，直接影响到线上的用户使用。但是大家发现在Android和Google浏览器里可以打开页面，但是在Safari浏览器和iOSAPP中打不开公司的HTTPS链接，而通过抓包，发现连接是有请求的，在Mac上的Safari浏览器中打开链接，发现宝如下错误</p><pre><code>Safari浏览器无法打开页面。错误是：“未能完成该操作。协议错误”（NSPOSIXErrorDomain Code=100）</code></pre><p>进一步使用Charles对公司的 HTTPS链接进行抓包发现，只要一抓包，所有的HTTPS链接都能打开，使用4G网、关掉抓包功能均不能成功打开链接。那么问题可以基本确定不是出在移动端。</p><p><strong>解决方案：通知服务端的同学禁止 HTTP 2.0</strong></p><p>参照答案:<a href="https://stackoverflow.com/questions/41461481/error-domain-nsposixerrordomain-code-100-protocol-error" target="_blank" rel="noopener">Stack Overflow</a>上</p>]]></content>
    
    <summary type="html">
    
      HTTPS WEB链接在iOS APP中打不开，在Android等其他平台能打开，在Safari浏览器不能打开，其他浏览器里能够打开。
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
      <category term="协议错误" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用Flutter(一):Flutter环境配置</title>
    <link href="http://yoursite.com/2018/10/18/Flutter%E7%AC%94%E8%AE%B0/Flutter%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/10/18/Flutter笔记/Flutter环境配置/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-29T11:36:21.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-获取-Flutter-SDK"><a href="#1-获取-Flutter-SDK" class="headerlink" title="1.获取 Flutter SDK"></a>1.获取 Flutter SDK</h2><ul><li><p>这一步可能会因墙而失败，不过Google为中国地区提供了镜像</p></li><li><p>先在.bash_profile（如果没有，新建一个即可） 中添加如下两行：</p><p>export PUB_HOSTED_URL=<a href="https://pub.flutter-io.cn" target="_blank" rel="noopener">https://pub.flutter-io.cn</a><br>export FLUTTER_STORAGE_BASE_URL=<a href="https://storage.flutter-io.cn" target="_blank" rel="noopener">https://storage.flutter-io.cn</a></p></li><li><p>用git将Flutter项目克隆到本地<br>git clone -b beta <a href="https://github.com/flutter/flutter.git" target="_blank" rel="noopener">https://github.com/flutter/flutter.git</a></p></li><li><p>添加环境变量，同样在.bash_profile 中添加下面一行代码</p><p>export PATH=”$PWD/flutter/bin:$PATH”</p></li><li><p>如果你是新建的.bash_profile 那么你需要在~/ 目录下运行如下指令 ，使其生效:</p><p>source .bash_profile</p><p>如果不运行以上指令，可能会在接下来的操作中碰到问题，后面会说</p></li></ul><p>## </p>]]></content>
    
    <summary type="html">
    
      其实也有很多同学写了相关的文章，但是上手的前期总是有很多问题的，这里是一篇简单的上手，在上手过程中，我也会把相关的问题和我成功解决问题方案链接直接放在其中，方便同学们一次性解决问题。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WKWebView 与 UIWebView 实现 OC与JS交互</title>
    <link href="http://yoursite.com/2018/08/28/OC%E4%B8%8EJS%20%E4%BA%A4%E4%BA%92/UIWebView%20%E5%AE%9E%E7%8E%B0%20OC%E4%B8%8EJS%E4%BA%A4%E4%BA%92/"/>
    <id>http://yoursite.com/2018/08/28/OC与JS 交互/UIWebView 实现 OC与JS交互/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2018-09-10T12:55:49.642Z</updated>
    
    <content type="html"><![CDATA[<!--# OC-And-JS-Interaction--><p>相关<a href="https://github.com/XFNicar/OC-and-JS-interaction" target="_blank" rel="noopener">示例源码</a>在这里</p><h2 id="为什么需要交互"><a href="#为什么需要交互" class="headerlink" title="为什么需要交互"></a>为什么需要交互</h2><blockquote><p>由于原生开发的时间周期相对表较长，难免带来一些更新不灵活的问题，有时候为了业务的需要不得不在原生APP中嵌入一些以Web实现的内容，大部分都是静态页面，一般也不会进行二次跳转，而这些页面有时候也会做一些与原生APP进行交互的功能，这些功能通常需要事先制定相应的协议，这些协议中的方法一般会当做通用的API，方便三端在新的规则出现时不需要反复制定规则，只需要在方法中更改相应的参数即可实现新规则下的交互。</p></blockquote><h2 id="WKWebView-amp-amp-UIWebView-实现-OC与JS交互"><a href="#WKWebView-amp-amp-UIWebView-实现-OC与JS交互" class="headerlink" title="WKWebView &amp;&amp; UIWebView 实现 OC与JS交互"></a>WKWebView &amp;&amp; UIWebView 实现 OC与JS交互</h2><blockquote><p>这里分别介绍使用 WKWebView 与 UIWebView 实现基本的 OC与JS 交互的方式，以及一些在业务上的个人建议。在代码上这些都是很容易实现的功能，关键点是如何使用这项功能，相关的HTML5 与 JS 文件都在<a href="https://github.com/XFNicar/OC-and-JS-interaction" target="_blank" rel="noopener">示例代码</a>中<br>，如有不明白的可以继续来这里看看文档。</p></blockquote><h3 id="用WKWebView-实现-OC与JS交互"><a href="#用WKWebView-实现-OC与JS交互" class="headerlink" title="用WKWebView 实现 OC与JS交互"></a>用WKWebView 实现 OC与JS交互</h3><ul><li><strong>准备工作</strong></li></ul><blockquote><ul><li>1 引入 WebKit 框架</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;WebKit/WebKit.h&gt;</span><br><span class="line">@interface WKWebViewController ()</span><br><span class="line">&lt;</span><br><span class="line">WKUIDelegate,</span><br><span class="line">WKNavigationDelegate,</span><br><span class="line">WKScriptMessageHandler// JS 调用原生需要实现的相关协议</span><br><span class="line">&gt;</span><br><span class="line">@property(nonatomic, strong) WKWebView *webView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><ul><li>2 创建 WKWebView 添加供JS调用的方法名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Getter</span><br><span class="line">- (WKWebView *)webView &#123;</span><br><span class="line">if (_webView == nil) &#123;</span><br><span class="line">    WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">    config.preferences = [[WKPreferences alloc] init];</span><br><span class="line">    config.preferences.minimumFontSize = 10;</span><br><span class="line">    config.preferences.javaScriptEnabled = YES;</span><br><span class="line">    config.preferences.javaScriptCanOpenWindowsAutomatically = NO;</span><br><span class="line">    config.userContentController = [[WKUserContentController alloc] init];</span><br><span class="line">    config.processPool = [[WKProcessPool alloc] init];</span><br><span class="line">    _webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:config];</span><br><span class="line">    _webView.UIDelegate = self;</span><br><span class="line">    _webView.navigationDelegate = self;</span><br><span class="line">    _webView.frame = self.view.bounds;</span><br><span class="line">    [config.userContentController addScriptMessageHandler:self name:@&quot;sendMsgToApp&quot;];</span><br><span class="line">&#125;</span><br><span class="line">return _webView;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><ul><li><p>3  这里需要介绍一下 <strong>WKWebViewConfiguration</strong>，不做深入了解的话可以跳过直接看代码 </p><p> <strong>WKWebView</strong> 初始化时，有一个参数叫<strong>configuration</strong>，它是<strong>WKWebViewConfiguration</strong>类型的参数，而<strong>WKWebViewConfiguration</strong>有一个属性叫<strong>userContentController</strong>，它又是<strong>WKUserContentController</strong>类型的参数。<strong>WKUserContentController</strong>对象有一个方法<strong>- addScriptMessageHandler:name:</strong>，我把这个功能简称为<strong>MessageHandler</strong>。添加<strong>MessageHandler</strong>其实就是添加供<strong>WKWebView</strong> 中 <strong>JS</strong> 调用的对象（<strong>heandle</strong>）和方法名(<strong>name</strong>)。</p></li></ul></blockquote><ul><li><strong>交互逻辑之 JS 调用 OC</strong></li></ul><blockquote><p>当我们注册了<strong>userContentController</strong>之后，JS 调用iOS原生就会走这个代理，并且会返回<strong>WKScriptMessage</strong>对象<strong>message</strong>，其中<strong>WKScriptMessage</strong>对象的两个属性是我们所需要的，<strong>message.name</strong> 是我们给JS添加的方法名，<strong>message.body</strong> 则是JS给我们发送的参数值，通常我们只需要注册一个方法名，业务逻辑的区分放到body里面来处理，这样可以方便前端与Native制定新的交互规则的时候，不需要维护新的公共API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - WKScriptMessageHandler</span><br><span class="line">/**</span><br><span class="line">此处接收并处理来自 JS 的调用</span><br><span class="line">可以根据message.name 来区分调用的是哪个方法 ，</span><br><span class="line">建议只设计一个通用方法来供JS调用</span><br><span class="line">然后根据参数值 message.body 来区分如何处理调用逻辑</span><br><span class="line">也可以根据  参数值来区分如何处理调用事件</span><br><span class="line">@param userContentController 控制器</span><br><span class="line">@param message ：</span><br><span class="line">            message.name (方法名)</span><br><span class="line">            message.body (参数)</span><br><span class="line">*/</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123;</span><br><span class="line">if ([message.name isEqualToString:@&quot;sendMsgToApp&quot;]) &#123; </span><br><span class="line">    [self sendMsgToApp:message];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - WKNavigationDelegate</span><br><span class="line">// webview跳转新页面的时候回调这个方法</span><br><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;#pragma mark WKUIDelegate</span><br><span class="line">// webview如果需要调用系统的控件(alert)则会调用这个方法, 如果设置了UIDelegate,没有实现这个方法，WebView的alert就不会弹出来</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123;</span><br><span class="line">UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;OC 调用 JS&quot; message:message preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">UIAlertAction *action = [UIAlertAction actionWithTitle:@&quot;知道了小肥仔&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line">   completionHandler();</span><br><span class="line">&#125;];</span><br><span class="line">[alert addAction:action];</span><br><span class="line">[self presentViewController:alert animated:YES completion:nil];&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong>交互逻辑之 OC 调用 JS</strong></li></ul><blockquote><p>   这里的代码非常简单，相关的调用只有一行代码:<br><strong>- evaluateJavaScript:jsStr completionHandler:</strong><br>其中<strong>sendMessageToWebView()</strong>是<strong>WebView</strong>公开给Native调用的公共接口，相关的参数转成字符串放到括号内即可，同样的，前端只需要公开一个API，相关的业务逻辑放到参数里面处理就可以了，也是为了减少维护公共API的成本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Native 调用 JS</span><br><span class="line">- (void)sendMessageToWebView:(UIBarButtonItem *)sender &#123;</span><br><span class="line"> NSString *msg = [NSString stringWithFormat:@&quot;我只是一只小兔几，我什么都不知道。&quot;];</span><br><span class="line">NSString * result = [self noWhiteSpaceString:msg];</span><br><span class="line">// sendMessageToWebView</span><br><span class="line">NSString * jsStr = [NSString stringWithFormat:@&quot;sendMessageToWebView(\&quot;%@\&quot;)&quot;,result];</span><br><span class="line">[self.webView evaluateJavaScript:jsStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123;</span><br><span class="line">    NSLog(@&quot;交互错误value :%@ error: %@&quot;,result,error);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="用-UIWebView-实现-OC-与-JS-交互"><a href="#用-UIWebView-实现-OC-与-JS-交互" class="headerlink" title="用 UIWebView 实现 OC 与 JS 交互"></a>用 UIWebView 实现 OC 与 JS 交互</h3><ul><li>准备工作</li></ul><blockquote><p>自然是创建<strong>UIWebView</strong>并设置代理了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.webView = [[UIWebView alloc]initWithFrame:CGRectMake(0, 20, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">self.webView.delegate = self;</span><br><span class="line">NSString* path = [[NSBundle mainBundle] pathForResource:@&quot;source&quot; ofType:@&quot;html&quot;];</span><br><span class="line">NSURL* url = [NSURL fileURLWithPath:path];</span><br><span class="line">NSURLRequest* request = [NSURLRequest requestWithURL:url] ;</span><br><span class="line">[self.webView loadRequest:request];</span><br><span class="line">[self.view addSubview:self.webView];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>遵守协议</li></ul><blockquote><p>在该协议中，定义供JS调用的方法，建议设置为一个通用接口，方便JS调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</span><br><span class="line">@protocol JSObjcDelegate &lt;JSExport&gt;</span><br><span class="line">/**</span><br><span class="line">前端调用Native</span><br><span class="line">此API用来供前端（H5）调用，</span><br><span class="line">为了方便制定调用的协议，</span><br><span class="line">此API应该设计成通用API，</span><br><span class="line">其中所涉及的场景应该由参数来决定，</span><br><span class="line">不应设计过多的API</span><br><span class="line">同理前端也应该只需设计一个API供Native调用</span><br><span class="line">@param param 调用参数</span><br><span class="line">*/</span><br><span class="line">- (void)sendMsgToApp:(NSString *)param;</span><br><span class="line">@end</span><br><span class="line">@interface UIWebViewController : UIViewController&lt;UIWebViewDelegate,JSObjcDelegate&gt;</span><br><span class="line">@property (nonatomic, strong) JSContext *jsContext;</span><br><span class="line">@property (strong, nonatomic)  UIWebView *webView;</span><br><span class="line">@end</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>实现协议方法，并向JSContext注册对象</li></ul><blockquote><p>所谓注册对象，就是告诉JS该调用谁的什么方法,总体来说也就是以下三行代码，只不过根据每个公司前端所写的业务不同，注入时机可能会有所区别，正常来说都是WebView通知Native在合适的时机注入即可，其中的区别我<a href="">写在这里</a>了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - UIWebViewDelegate</span><br><span class="line">- (void)webViewDidStartLoad:(UIWebView *)webView &#123;</span><br><span class="line">self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];</span><br><span class="line">// 将JS中的iOS_NativeModel对象（JS中定义为什么名称就是什么名称）设置为当前控制器，JS才可以调用当前控制器所遵守协议中的方法</span><br><span class="line">self.jsContext[@&quot;iOS_NativeModel&quot;] = self;</span><br><span class="line">self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) &#123;</span><br><span class="line">context.exception = exceptionValue;</span><br><span class="line">    NSLog(@&quot;异常信息：%@&quot;, exceptionValue);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>JS 调用 Native</li></ul><blockquote><p>这里就是在WebView所在的控制器实现之前的协议中的方法即可，JS调用协议中的方法就会来到方法的具体实现，PS：JS所传值为字符串，需要根据相关业务参数看是否需要转化为JSON或其他对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - JSObjcDelegate </span><br><span class="line">// 为保证交互结果的安全可控</span><br><span class="line">// 在native中执行的相关代码务必放在主线程中执行</span><br><span class="line">- (void)sendMsgToApp:(NSString *)param &#123;</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;param:%@&quot;,param);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>OC 调用 JS</li></ul><blockquote><p>这里比<strong>WKWebView</strong>稍微复杂一些，但是基本原理是一样的，<strong>UIWebView</strong>这里使用<strong>JSValue</strong>对象来实现，设置所调用的JS函数与参数与<strong>WKWebView</strong>是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Public</span><br><span class="line">// 通过 JSValue 对象发送消息给 WEB 页面</span><br><span class="line">- (void)sendMessageToWebView:(UIBarButtonItem *)sender &#123;</span><br><span class="line">JSValue *jsObject = self.jsContext[@&quot;receiveMsgFromApp&quot;];</span><br><span class="line">NSString *param = [NSString stringWithFormat:@&quot;%@\n%@\n%@\n详细信息：%@&quot;,@&quot;商品获取成功&quot;,@&quot;商品名称:哈哈&quot;,@&quot;商品ID：123456&quot;,@&quot;这是商品信息&quot;];</span><br><span class="line">NSString *callBackStr = [NSString stringWithFormat:@&quot;receiveMsgFromApp(%@)&quot;, param ];</span><br><span class="line">[jsObject callWithArguments:@[callBackStr]];</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="OC与JS交互的简单介绍就到此为止了，如需深入了解，可以关注我的其他内容"><a href="#OC与JS交互的简单介绍就到此为止了，如需深入了解，可以关注我的其他内容" class="headerlink" title="OC与JS交互的简单介绍就到此为止了，如需深入了解，可以关注我的其他内容"></a>OC与JS交互的简单介绍就到此为止了，如需深入了解，可以关注我的其他内容</h2>]]></content>
    
    <summary type="html">
    
      分别使用 WKWebView 与 UIWebView 实现OC与JS简单交互，以及有关交互业务方面的一点点建议。
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="OC与JS交互" scheme="http://yoursite.com/tags/OC%E4%B8%8EJS%E4%BA%A4%E4%BA%92/"/>
    
      <category term="UIWebView" scheme="http://yoursite.com/tags/UIWebView/"/>
    
      <category term="WKWebView" scheme="http://yoursite.com/tags/WKWebView/"/>
    
  </entry>
  
  <entry>
    <title>cocoapods 安装 WCDB 报“Permission denied”错误</title>
    <link href="http://yoursite.com/2018/08/23/WCDB/WCDB%20cocoapods%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5/"/>
    <id>http://yoursite.com/2018/08/23/WCDB/WCDB cocoapods安装失败/</id>
    <published>2018-08-22T16:00:00.000Z</published>
    <updated>2018-08-28T15:41:14.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>腾讯去年开源的数据库第三方库<a href="https://github.com/Tencent/wcdb/wiki" target="_blank" rel="noopener">WCDB</a> 无疑成为了开发圈里的话题，作为一款生产工具，它绝不是话题那么简单，很多开发者都开始围绕 <a href="https://github.com/Tencent/wcdb/wiki" target="_blank" rel="noopener">WCDB</a> 优化自己的项目了。不过在使用之前也可能会遇到一些小问题，比如pod安装 <a href="https://github.com/Tencent/wcdb/wiki" target="_blank" rel="noopener">WCDB</a> 的时候，会修改xcode部分目录下的一些文件，这其中包括新增模板和代码块。当新增代码块的时候，有时候会安装失败，原因是保存代码快的目录<code>~/Library/Developer/Xcode/UserData/CodeSnippets/</code>属于 root 用户，对root用户为可读写，对其他用户为只读，所以，运行<code>$pod install</code> ，最终会报出有关权限不够的错误：<code>Permission denied</code>。</p><h2 id="Permission-denied-错误"><a href="#Permission-denied-错误" class="headerlink" title="Permission denied 错误"></a>Permission denied 错误</h2><pre><code>pod install Analyzing dependencies[!] The version of CocoaPods used to generate the lockfile (1.5.3) is higher than the version of the current executable (1.5.2). Incompatibility issues may arise.Downloading dependenciesInstalling WCDB (1.0.6)  [!] /bin/bash -c   set -egit submodule update --init sqlcipher;                           cd tools/templates; sh install.sh; cd ../..;                           cd sqlcipher; make -f Makefile.preprocessed; cd ..;                           cp sqlcipher/ext/fts3/fts3_tokenizer.h sqlcipher/Submodule path &apos;sqlcipher&apos;: checked out &apos;d4726337010f60408a9c99633b35f01a8a7ae2de&apos;Submodule &apos;sqlcipher&apos; (https://github.com/Tencent/sqlcipher.git) registered for path &apos;sqlcipher&apos;Cloning into &apos;~/Library/Caches/CocoaPods/Pods/Release/WCDB/1.0.6-4d292/sqlcipher&apos;...cp: ~/Library/Developer/Xcode/UserData/CodeSnippets/WCDB.ColumnCodableClass.Data.swift.codesnippet: Permission deniedcp: ~/Library/Developer/Xcode/UserData/CodeSnippets/WCDB.ColumnCodableClass.Double.swift.codesnippet: Permission deniedcp: ~/Library/Developer/Xcode/UserData/CodeSnippets/WCDB.ColumnCodableClass.Int32.swift.codesnippet: Permission deniedcp: ~/Library/Developer/Xcode/UserData/CodeSnippets/WCDB.ColumnCodableClass.Int64.swift.codesnippet: Permission deniedcp: ~/Library/Developer/Xcode/UserData/CodeSnippets/WCDB.ColumnCodableClass.String.swift.codesnippet: Permission deniedcp: ~/Library/Developer/Xcode/UserData/CodeSnippets/WCDB.TableCodableClass.swift.codesnippet: Permission denied  </code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>###方法一 </p><pre><code>$cd  ~/Library/Developer/Xcode/UserData/$sudo chmod -R 777 CodeSnippets$cd &quot;你的工程目录&quot;$pod install</code></pre><p>###方法二<br><strong>前往以下文件夹</strong></p><pre><code>~/Library/Developer/Xcode/UserData/</code></pre><p><strong>找到以下文件夹</strong></p><pre><code>CodeSnippets</code></pre><p><strong>右键-显示简介</strong></p><pre><code>在右下方解除锁定，修改staff用户的权限为读写</code></pre>]]></content>
    
    <summary type="html">
    
      pod安装 WCDB 的时候，会修改xcode部分目录下的一些文件，这其中包括新增模板和代码块。由于该目录的所属用户可能为root用户，又或者使用者权限不够，新增代码块的时候，有时候会安装失败。
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="cocoapods" scheme="http://yoursite.com/tags/cocoapods/"/>
    
      <category term="WCDB" scheme="http://yoursite.com/tags/WCDB/"/>
    
  </entry>
  
  <entry>
    <title>英语美文</title>
    <link href="http://yoursite.com/2018/08/22/EnglishStudy/English%20Article/"/>
    <id>http://yoursite.com/2018/08/22/EnglishStudy/English Article/</id>
    <published>2018-08-21T16:00:00.000Z</published>
    <updated>2018-08-25T14:21:49.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Benjamin-Button’s-Letter-to-Daughter"><a href="#Benjamin-Button’s-Letter-to-Daughter" class="headerlink" title="Benjamin Button’s Letter to Daughter"></a>Benjamin Button’s Letter to Daughter</h2><pre><code>For what it&apos;s worth:It&apos;s never too late,or in my case,too early to be whoever you want to be.There&apos;s no time limit. Start whenever you want.You can change or stay the same. There are no rules to this thing.We can make the best or the worst of it.I hope you make the best of it.And I hope you see things that startle you.I hope you feel things you never felt before.I hope you meet people with a defferent point of view.I hope you live a life you&apos;re proud of.If you find that you;re not, I hope you have the strength to start all over again.</code></pre><h2 id="If-You-Think…"><a href="#If-You-Think…" class="headerlink" title="If You Think…"></a>If You Think…</h2><pre><code>If you think you are beaten, you are.If you think you dare not, you don&apos;t.If you want win,but think you cant,it&apos;s almost a cinch you won&apos;t.If you think you&apos;ll lose,you&apos;re lost; for out in the world we find success begins with a fellow&apos;s will.It&apos;s all in the state of the mind.Life&apos;s gattles don&apos;t always go to the stronger and faster man.But sonner or later the man who wins is the man who thinks he can.</code></pre>]]></content>
    
    <summary type="html">
    
      每天阅读一篇英语短文，慢慢提升英语爱好。
    
    </summary>
    
      <category term="英语学习" scheme="http://yoursite.com/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="文章" scheme="http://yoursite.com/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>iOS 11 UITableView刷新漂移/抖动</title>
    <link href="http://yoursite.com/2018/08/08/iOS%E9%80%82%E9%85%8D%E5%B0%8F%E4%BC%98%E5%8C%96/iOS11%20tableView%E5%88%B7%E6%96%B0%E6%BC%82%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/08/iOS适配小优化/iOS11 tableView刷新漂移问题/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2018-08-08T02:11:39.197Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我们做了什么？"><a href="#我们做了什么？" class="headerlink" title="我们做了什么？"></a>我们做了什么？</h3><ul><li>在我们的APP中，静态界面一般很少使用，大部分的页面都是用了UITableView，用来动态展示信息，这里少不了使用动态布局方案，以及Cell的动态高度计算方案，其中就包括预设高度，以及手动动态计算等。在iOS 11 之前，我们可能不会有任何问题，当我们来到iOS 11之后，问题来了，预设高度，让系统根据布局来动态计算的方案，在有些时候就出现了刷新TableView漂移的现象。</li></ul><h3 id="苹果的tabieView动态展示方案"><a href="#苹果的tabieView动态展示方案" class="headerlink" title="苹果的tabieView动态展示方案"></a>苹果的tabieView动态展示方案</h3><ul><li><p>在iOS 8中，苹果引入了UITableView 的一项新功能（Self Sizing Cells）,在iOS 8之前，如果想在UITableView中展示可变高度的动态内容时，需要开发者手动计算行高，Self Sizing Cells 的引入，为动态展示动态内容提供了一个解决方案，这个方案对系统cell和xib都有效。</p></li><li><p>根据苹果官方文档的解释：Self-Sizing开启之后，开发者不用再自己去计算cell的高度，只要设置好相关属性，约束好布局，系统会自动计算好cell的高度。</p></li><li><p>在iOS 11之前，Self Sizing Cells是默认不开启的，当我们来到iOS 11后系统默认开启Self-Sizing，此时，如果我们手动计算高度，有没有关闭Self Sizing Cells相关属性，刷新TableView的时候就可能会出现漂移现象。</p></li></ul><h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul><li><p>如果你不需要系统帮你计算cells高度，那么我们就应该关闭Self Sizing Cells相关属性：</p><pre><code>self.tableView.estimatedRowHeight=0;self.tableView.estimatedSectionHeaderHeight = 0;self.tableView.estimatedSectionFooterHeight = 0;</code></pre></li><li><p>如果我们需要系统帮忙计算cells高度，那么我们就应该利用好相关的属性：</p><pre><code>self.tableView.estimatedRowHeight = 100; //  设置任意不等于0 的值self.tableView.rowHeight = UITableViewAutomaticDimension;self.tableView.estimatedSectionHeaderHeight = 35;  // 如有需要也应该设置self.tableView.estimatedSectionFooterHeight = 35;  // 如有需要也应该设置</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      相信很多小伙伴来到iOS 11 之后，以前写的一些TableView内容突然开始不听实话，刷新的时候出现了漂移的现象，为什么呢，带着疑问，我们先来一探究竟吧。
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="小优化" scheme="http://yoursite.com/tags/%E5%B0%8F%E4%BC%98%E5%8C%96/"/>
    
      <category term="UITableView" scheme="http://yoursite.com/tags/UITableView/"/>
    
  </entry>
  
  <entry>
    <title>iOS组件化之路-同名文件带来的坑</title>
    <link href="http://yoursite.com/2018/08/01/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%88%B0%E7%9A%84%E5%9D%91/iOS%E5%B7%A5%E7%A8%8B%E5%A4%9Atarget%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/01/组件化到的坑/iOS工程多target问题/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2018-08-02T01:00:36.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案-一-最优雅的方式：功能一样的同名文件组件化"><a href="#方案-一-最优雅的方式：功能一样的同名文件组件化" class="headerlink" title="方案 一  最优雅的方式：功能一样的同名文件组件化"></a>方案 一  最优雅的方式：功能一样的同名文件组件化</h3><p>  这种方式应该是这个问题最优雅的解决方案了，在开发过程中要尽可能的避免项目中存在同名文件，他们往往是实现完全一样的功能的代码，既然我们都已经组件化了，那么同名文件自然而然的要想到做组件化处理，无需放在多个不一样的target中，只需要将这个共同的功能作为依赖库包含在不同的模块中即可。</p><h3 id="方案-二-取巧的方案：映射"><a href="#方案-二-取巧的方案：映射" class="headerlink" title="方案 二  取巧的方案：映射"></a>方案 二  取巧的方案：映射</h3><p>  这种情况仅仅在你不得不使用一个单利，但是你又暂时无法将某个同样的功能从两个target中剥离出来（比如微信支付），那么将会在两个target中共同存在相同的微信SDK，此时支付等功能的回调肯定需要依赖一个中间对象，那么就必须保证无论你是在同一个target下，还是多个target下，都必须是同一个实例对象。而你在不同的target下的同名文件，即使你这个类是单例，实例化对象的时候也不可能返回同一个实例对象，那么此时，只能一方移除该文件，不在引用该类的头文件，使用映射的方式，以字符串生成类名来实例出某个特定的单利（前提是你的单利实例化方法一定要写的够完善），此方案仅仅适合作为临时取巧，仅仅是一种解决方案。</p>]]></content>
    
    <summary type="html">
    
      场景描述：在公司的开发过程中，我们采用了组件化的方式，将代码按照相关功能进行剥离，同时对某些相应的模块独立到一个单独的工程里开发，两个工程里面均独立包含第三方支付功能，那么此时，两个工程里面都包含同样的第三方支付SDK。当代码实施组件化之后，他们可以存在于同一个工程里面，此时可能会引起一些问题，对这些&quot;微信&quot;、&quot;支付宝&quot;等第三方SDK在APP delegate中的回调，我们通常会自己实现一些起中间处理的helper类或者单利来方便全局调用。在不同target下的单利，实例化之后，虽然是同名类，但是实例化出来却不是同一个对象，这导致主工程里面的delegate无法令除主工程以外的target下的回调生效，这是我在处理微信支付的过程中所遇到的问题。
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="坑" scheme="http://yoursite.com/tags/%E5%9D%91/"/>
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="多target" scheme="http://yoursite.com/tags/%E5%A4%9Atarget/"/>
    
  </entry>
  
  <entry>
    <title>英语美句</title>
    <link href="http://yoursite.com/2018/07/29/EnglishStudy/English%20Sentences/"/>
    <id>http://yoursite.com/2018/07/29/EnglishStudy/English Sentences/</id>
    <published>2018-07-28T16:00:00.000Z</published>
    <updated>2018-08-08T03:13:04.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英语美句"><a href="#英语美句" class="headerlink" title="英语美句"></a>英语美句</h1><h2 id="每天收集一些精美的英语小句子，慢慢提升英语爱好。"><a href="#每天收集一些精美的英语小句子，慢慢提升英语爱好。" class="headerlink" title="每天收集一些精美的英语小句子，慢慢提升英语爱好。"></a>每天收集一些精美的英语小句子，慢慢提升英语爱好。</h2><ul><li><p>赠人玫瑰，手有余香。<br>  Give a person a rose and keep his hand in the rost. </p></li><li><p>两颗相爱的心之间不需要言语。<br>  No words are necessary between two loving hearts.</p></li><li><p>成功者是坚持梦想不放弃的人。<br>  A winner is a dreamer who never gives up.</p></li></ul>]]></content>
    
    <summary type="html">
    
      每天收集一些精美的英语小句子，慢慢提升英语爱好。
    
    </summary>
    
      <category term="英语学习" scheme="http://yoursite.com/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="英语" scheme="http://yoursite.com/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>iOS 10.3 UILabel 中划线无效</title>
    <link href="http://yoursite.com/2018/05/15/iOS10%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/iOS%2010.3%20UILabel%20%E5%88%A0%E9%99%A4%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/15/iOS10适配问题汇总/iOS 10.3 UILabel 删除线问题/</id>
    <published>2018-05-15T13:36:43.000Z</published>
    <updated>2018-08-01T12:05:55.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在iOS10-3系统-给-UILabel-添加中划线失效"><a href="#在iOS10-3系统-给-UILabel-添加中划线失效" class="headerlink" title="在iOS10.3系统 给 UILabel 添加中划线失效"></a>在iOS10.3系统 给 UILabel 添加中划线失效</h2><h3 id="通常使用的代码为"><a href="#通常使用的代码为" class="headerlink" title="通常使用的代码为"></a>通常使用的代码为</h3><pre><code>- (NSMutableAttributedString *)setUnderlineStyle {// 此方法为我们常用的方法[self setAttributes:@{NSStrikethroughStyleAttributeName: [NSNumber numberWithInteger:NSUnderlineStyleSingle]} range:NSMakeRange(0, self.length)];return self;}</code></pre><p>###以下代码将一举解决 iOS10.3 中划线不生效的系统bug</p><pre><code>- (NSMutableAttributedString *)setUnderlineStyle {    // 此 一举解决 iOS 10.3 不显示删除线的系统bug    [self setAttributes:@{NSStrikethroughStyleAttributeName: [NSNumber numberWithInteger:NSUnderlineStyleSingle],NSBaselineOffsetAttributeName : @(NSUnderlineStyleSingle)} range:NSMakeRange(0, self.length)];    return self; }</code></pre>]]></content>
    
    <summary type="html">
    
      在iOS10.3系统 给 UILabel 添加中划线失效
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="iOS 10.3 代码适配问题" scheme="http://yoursite.com/tags/iOS-10-3-%E4%BB%A3%E7%A0%81%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    
      <category term="NSString" scheme="http://yoursite.com/tags/NSString/"/>
    
      <category term="UILabel" scheme="http://yoursite.com/tags/UILabel/"/>
    
  </entry>
  
  <entry>
    <title>人民币货币符号与价格之间的空格</title>
    <link href="http://yoursite.com/2018/05/15/iOS%E9%80%82%E9%85%8D%E5%B0%8F%E4%BC%98%E5%8C%96/iOS9%20%E4%BA%BA%E6%B0%91%E5%B8%81%E7%AC%A6%E5%8F%B7%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/15/iOS适配小优化/iOS9 人民币符号适配问题/</id>
    <published>2018-05-15T13:14:43.000Z</published>
    <updated>2018-08-08T01:23:55.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS-9系统下-“人民币的特殊性”"><a href="#iOS-9系统下-“人民币的特殊性”" class="headerlink" title="iOS 9系统下 “人民币的特殊性”"></a>iOS 9系统下 “人民币的特殊性”</h2><pre><code>NSString * string = @&quot;9999&quot;;NSNumberFormatter *moneyFormatter = [[NSNumberFormatter alloc] init];moneyFormatter.numberStyle = kCFNumberFormatterCurrencyStyle;NSString *priceString = [moneyFormatter stringFromNumber:[NSNumber numberWithDouble:[string doubleValue]]];NSMutableString *priceMstr = [NSMutableString stringWithFormat:@&quot;%@&quot;,priceString];NSLog(@&quot;%@&quot;,priceMstr);</code></pre><p> 其输出结果为 “￥ 9,999.00” ，而不是我们预期的 “￥9,999.00”。</p><pre><code> ￥ 与 &quot;9,999.00&quot; 之间的空白地带，是无法用替换空格的方式直接消除的的。 即使用如下方法将不起作用 NSRange range = [priceMstr rangeOfString:@&quot; &quot;]; if (range.location != NSNotFound) {    [priceMstr replaceCharactersInRange:range withString:@&quot;&quot;];}</code></pre><p>看来它是一个特殊的字符那么我们不得不采用其他的办法来处理。</p><p>添加如下代码即可处理掉人民币货币符号 与 价格之间的空格:</p><pre><code>[priceMstr stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</code></pre>]]></content>
    
    <summary type="html">
    
      人民币是一种特殊的货币吗？答案是：是的。当使用系统自带方法，给货币自动添加货币符号，以及价格千分位之后，在iOS 9系统上，如果货币为人民币，人民币会与其他货币符号产生不一样的输出效果，即人民币符号&quot;￥&quot;与价格之间会有一个空白间距。
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="NSString" scheme="http://yoursite.com/tags/NSString/"/>
    
      <category term="小优化" scheme="http://yoursite.com/tags/%E5%B0%8F%E4%BC%98%E5%8C%96/"/>
    
      <category term="kCFNumberFormatterCurrencyStyle" scheme="http://yoursite.com/tags/kCFNumberFormatterCurrencyStyle/"/>
    
  </entry>
  
  <entry>
    <title>用CollectionView实现环形布局</title>
    <link href="http://yoursite.com/2018/05/10/CollectionView/CollectionView%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/05/10/CollectionView/CollectionView实现环形布局/</id>
    <published>2018-05-09T17:08:43.000Z</published>
    <updated>2018-08-08T02:22:27.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XFCyclicAnnularFlowLayout"><a href="#XFCyclicAnnularFlowLayout" class="headerlink" title="XFCyclicAnnularFlowLayout"></a>XFCyclicAnnularFlowLayout</h2><h3 id="CollectionView-实现扇形（环形）布局"><a href="#CollectionView-实现扇形（环形）布局" class="headerlink" title="CollectionView 实现扇形（环形）布局"></a>CollectionView 实现扇形（环形）布局</h3><font color="green" size="4.5"><strong>功能设置</strong></font><ul><li><p>1.设置有多少层扇形（环形）</p></li><li><p>2.设置该层有多少元素</p></li><li><p>3.设置元素大小Size</p></li><li><p>4.设置该层环绕的半径</p></li><li><p>5.设置该层扇形的展开弧度</p></li><li><p>6.设置所有元素的朝向</p><ul><li><font color="#660000">朝上（默认）</font><br></li><li><font color="#660000">朝下</font><br></li><li><font color="#660000">朝里（头部指向圆心）</font><br></li><li><font color="#660000">朝外（头部与环形法线方向一致）</font><br></li></ul></li><li><p>7.设置该层环形中所有元素是否顺时针排布</p><ul><li><font color="#660000">默认是顺时针排布</font><br></li></ul></li></ul><font color="green" ,="" size="4.5"><strong>API说明</strong></font><ul><li><p><strong>当前组的扇形（环形）半径</strong></p><pre><code>- (CGFloat)flowLayout:(XFCyclicAnnularFlowLayout *)flowLayout cyclicAnnularRadiusInSection:(NSInteger)section;</code></pre><p>  <strong><em>返回参数类型值说明如下：</em></strong></p><pre><code>CGFloat 返回当前组扇形（环形）的半径 (单位: π)</code></pre></li><li><p><strong>当前位置Cell的大小（size）</strong></p><pre><code>- (CGSize)flowLayout:(XFCyclicAnnularFlowLayout *)flowLayout cyclicAnnularItemSizeAtindexPath:(NSIndexPath *)indexPath;</code></pre><p>  <strong><em>返回参数类型值说明如下：</em></strong></p><pre><code>CGSize  返回当前位置（indexPath）cell的大小</code></pre></li></ul><ul><li><p><strong>当前组的弧度范围（即该组展开弧度）</strong></p><pre><code>- (CGFloat)flowLayout:(XFCyclicAnnularFlowLayout *)flowLayout cyclicAnnularRadianInSection:(NSInteger)section;</code></pre><p>   <strong><em>返回参数类型值说明如下：</em></strong></p><pre><code>CGFloat  返回当前组元素在视图上展开的弧度范围</code></pre></li><li><p><strong>该组元素在扇形区域内是否顺时针展开</strong></p><pre><code>- (BOOL )flowLayout:(XFCyclicAnnularFlowLayout *)flowLayout cyclicIsClockwiseInSection:(NSInteger)section;</code></pre><p>  <strong><em>返回参数类型值说明如下：</em></strong></p><pre><code>BOOL  该返回值设定视图当前环形中cell是顺时针依次排列，还是逆时针依次排列，默认是顺时针</code></pre></li><li><p><strong>元素朝向</strong></p><pre><code>- (XFCyclicAnnularItemOrientation )cyclicAnnularItemOrientationInFlowLayout:(XFCyclicAnnularFlowLayout *)flowLyout;</code></pre><p>  <strong><em>返回参数类型值说明如下：</em></strong></p></li></ul><pre><code>typedef NS_ENUM(NSUInteger, XFCyclicAnnularItemOrientation) {    XFCyclicAnnularItemOrientationUp,           // 朝上 默认    XFCyclicAnnularItemOrientationDown,         // 朝下    XFCyclicAnnularItemOrientationInside,       // 朝内    XFCyclicAnnularItemOrientationOutside       // 朝外};</code></pre>]]></content>
    
    <summary type="html">
    
      用很多时候,项目中会出现一系列元素排布在一系列圆环至上,该文章将给到一个用UIColectionView来实现该需求的基本思路,该方案API简单易理解,使用方便。
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="环形布局" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%BD%A2%E5%B8%83%E5%B1%80/"/>
    
      <category term="UICollectionView" scheme="http://yoursite.com/tags/UICollectionView/"/>
    
      <category term="UICollectionViewFlowLayout" scheme="http://yoursite.com/tags/UICollectionViewFlowLayout/"/>
    
  </entry>
  
  <entry>
    <title>程序员应该知道自己要做什么</title>
    <link href="http://yoursite.com/2017/07/16/H.264/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    <id>http://yoursite.com/2017/07/16/H.264/程序人生/</id>
    <published>2017-07-16T12:33:43.000Z</published>
    <updated>2018-08-28T15:38:31.760Z</updated>
    
    <content type="html"><![CDATA[<p>写在这里，告诉自己，职业人生应该是有一定自我主动权的。</p><p>不要因为工作放弃自己曾经那份充满热爱的感觉。</p><p>总是会越写越困，困的时候会失去动力，是坚持不下去，还是真的累了呢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写在这里，告诉自己，职业人生应该是有一定自我主动权的。&lt;/p&gt;
&lt;p&gt;不要因为工作放弃自己曾经那份充满热爱的感觉。&lt;/p&gt;
&lt;p&gt;总是会越写越困，困的时候会失去动力，是坚持不下去，还是真的累了呢。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objective-C 修饰词详解</title>
    <link href="http://yoursite.com/2015/09/10/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/Objective-C%E4%BF%AE%E9%A5%B0%E8%AF%8D%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2015/09/10/iOS开发笔记/Objective-C修饰词详解/</id>
    <published>2015-09-09T16:00:00.000Z</published>
    <updated>2018-09-10T15:06:02.594Z</updated>
    
    <summary type="html">
    
      相信很多小伙伴对修饰词的理解往往停留在表面意思上面，亦或者只知道什么样的属性应该用什么样的关键字比较，但不未必知道为什么要这么用。
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="iOS开发" scheme="http://yoursite.com/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="修饰词" scheme="http://yoursite.com/tags/%E4%BF%AE%E9%A5%B0%E8%AF%8D/"/>
    
  </entry>
  
</feed>
